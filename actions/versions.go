package actions

import (
	"fmt"

	"github.com/flyinprogrammer/vlad/models"
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/pkg/errors"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Version)
// DB Table: Plural (versions)
// Resource: Plural (Versions)
// Path: Plural (/versions)
// View Template Folder: Plural (/templates/versions/)

// VersionsResource is the resource for the Version model
type VersionsResource struct {
	buffalo.Resource
}

// Create adds a Version to the DB. This function is mapped to the
// path POST /versions
func (v VersionsResource) Create(c buffalo.Context) error {
	versionReq := &models.VersionRequest{}

	// Bind version to the html form elements
	if err := c.Bind(versionReq); err != nil {
		return errors.WithStack(err)
	}

	version := versionReq.ToVersion()

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	username := c.Param("username")
	name := c.Param("name")

	boxes := &models.Boxes{}

	if err := tx.Where("username = ?", username).Where("name = ?", name).All(boxes); err != nil {
		return errors.WithStack(err)
	}

	if len(*boxes) == 0 {
		return c.Error(404, errors.New(fmt.Sprintf("no box found for: username: %s name %s", username, name)))
	}

	if len(*boxes) > 1 {
		return c.Error(503, errors.New(fmt.Sprintf("too many (%d) boxes found", len(*boxes))))
	}

	version.BoxID = (*boxes)[0].ID

	version.Status = string(models.VersionStatusUnreleased)

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(&version)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the new.html template that the user can
		// correct the input.
		return c.Render(422, r.JSON(&version))
	}

	// and redirect to the versions index page
	return c.Render(200, r.JSON(&version))
}

// Release updates a Version to a Status of Active
// path POST /versions
func (v VersionsResource) Release(c buffalo.Context) error {

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	username := c.Param("username")
	name := c.Param("name")
	version := c.Param("version")

	query := tx.Q().Join("boxes", "boxes.id=versions.box_id").
		Where("boxes.username like ?", username).
		Where("boxes.name like ?", name).
		Where("version = ?", version)

	versions := &models.Versions{}

	if err := query.All(versions); err != nil {
		return errors.WithStack(err)
	}

	if len(*versions) == 0 {
		return c.Error(404, errors.New(fmt.Sprintf("no version found for: username: %s name: %s version: %s", username, name, version)))
	}

	if len(*versions) > 1 {
		return c.Error(503, errors.New(fmt.Sprintf("too many (%d) boxes found", len(*versions))))
	}

	ver := (*versions)[0]

	ver.Status = string(models.VersionStatusActive)

	// Validate the data from the html form
	verrs, err := tx.ValidateAndUpdate(&ver)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the new.html template that the user can
		// correct the input.
		return c.Render(422, r.JSON(&ver))
	}

	// and redirect to the versions index page
	return c.Render(200, r.JSON(&ver))
}

// Revoke updates a Version to a Status of Revoke
// path POST /versions
func (v VersionsResource) Revoke(c buffalo.Context) error {

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	username := c.Param("username")
	name := c.Param("name")
	version := c.Param("version")

	query := tx.Q().Join("boxes", "boxes.id=versions.box_id").
		Where("boxes.username like ?", username).
		Where("boxes.name like ?", name).
		Where("version = ?", version)

	versions := &models.Versions{}

	if err := query.All(versions); err != nil {
		return errors.WithStack(err)
	}

	if len(*versions) == 0 {
		return c.Error(404, errors.New(fmt.Sprintf("no version found for: username: %s name: %s version: %s", username, name, version)))
	}

	if len(*versions) > 1 {
		return c.Error(503, errors.New(fmt.Sprintf("too many (%d) boxes found", len(*versions))))
	}

	ver := (*versions)[0]

	ver.Status = string(models.VersionStatusRevoked)

	// Validate the data from the html form
	verrs, err := tx.ValidateAndUpdate(&ver)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the new.html template that the user can
		// correct the input.
		return c.Render(422, r.JSON(&ver))
	}

	// and redirect to the versions index page
	return c.Render(200, r.JSON(&ver))
}
