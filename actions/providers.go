package actions

import (
	"fmt"

	"github.com/flyinprogrammer/vlad/models"
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/pkg/errors"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Provider)
// DB Table: Plural (providers)
// Resource: Plural (Providers)
// Path: Plural (/providers)
// View Template Folder: Plural (/templates/providers/)

// ProvidersResource is the resource for the Provider model
type ProvidersResource struct {
	buffalo.Resource
}

// Create adds a Provider to the DB. This function is mapped to the
// path POST /providers
func (v ProvidersResource) Create(c buffalo.Context) error {
	// Allocate an empty Provider
	providerReq := &models.ProviderRequest{}

	// Bind provider to the html form elements
	if err := c.Bind(providerReq); err != nil {
		return errors.WithStack(err)
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	provider := providerReq.ToProvider()

	username := c.Param("username")
	name := c.Param("name")
	version := c.Param("version")

	query := tx.Q().Join("boxes", "boxes.id=versions.box_id").
		Where("boxes.username like ?", username).
		Where("boxes.name like ?", name).
		Where("version = ?", version)

	versions := &models.Versions{}

	if err := query.All(versions); err != nil {
		return errors.WithStack(err)
	}

	if len(*versions) == 0 {
		return c.Error(404, errors.New(fmt.Sprintf("no version found for: username: %s name: %s version: %s", username, name, version)))
	}

	if len(*versions) > 1 {
		return c.Error(503, errors.New(fmt.Sprintf("too many (%d) boxes found", len(*versions))))
	}

	provider.VersionID = (*versions)[0].ID

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(&provider)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the new.html template that the user can
		// correct the input.
		return c.Render(422, r.JSON(&provider))
	}

	// and redirect to the providers index page
	return c.Render(200, r.JSON(&provider))
}
