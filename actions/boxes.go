package actions

import (
	"fmt"
	"time"

	"github.com/flyinprogrammer/vlad/models"
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/pkg/errors"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Box)
// DB Table: Plural (boxes)
// Resource: Plural (Boxes)
// Path: Plural (/boxes)
// View Template Folder: Plural (/templates/boxes/)

// BoxesResource is the resource for the Box model
type BoxesResource struct {
	buffalo.Resource
}

// Create adds a Box to the DB. This function is mapped to the
// path POST /boxes
func (v BoxesResource) Create(c buffalo.Context) error {
	// Allocate an empty Box
	boxReq := &models.BoxRequest{}

	// Bind box to the html form elements
	if err := c.Bind(boxReq); err != nil {
		return errors.WithStack(err)
	}

	box := boxReq.ToBox()
	boxAddr := &box

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(boxAddr)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the new.html template that the user can
		// correct the input.
		return c.Render(422, r.JSON(boxAddr))
	}

	// and redirect to the boxes index page
	return c.Render(200, r.JSON(boxAddr))
}

type ReadBoxResponse struct {
	CreatedAt           time.Time       `json:"created_at"`
	DescriptionHTML     string          `json:"description_html"`
	DescriptionMarkdown string          `json:"description_markdown"`
	Downloads           int             `json:"downloads"`
	Name                string          `json:"name"`
	Private             bool            `json:"private"`
	ShortDescription    string          `json:"short_description"`
	Tag                 string          `json:"tag"`
	UpdatedAt           time.Time       `json:"updated_at"`
	Username            string          `json:"username"`
	CurrentVersion      *models.Version `json:"current_version,omitempty"`
	Versions            models.Versions `json:"versions,omitempty"`
}

func (v BoxesResource) ReadBox(c buffalo.Context) error {

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	username := c.Param("username")
	name := c.Param("name")

	boxes := &models.Boxes{}

	if err := tx.Where("username = ?", username).Where("name = ?", name).All(boxes); err != nil {
		return errors.WithStack(err)
	}

	if len(*boxes) == 0 {
		return c.Error(404, errors.New(fmt.Sprintf("no box found for: username: %s name %s", username, name)))
	}

	if len(*boxes) > 1 {
		return c.Error(503, errors.New(fmt.Sprintf("too many (%d) boxes found", len(*boxes))))
	}

	box := (*boxes)[0]

	resp := ReadBoxResponse{
		CreatedAt:           box.CreatedAt,
		DescriptionHTML:     box.DescriptionHTML,
		DescriptionMarkdown: box.DescriptionMarkdown,
		Downloads:           box.Downloads,
		Name:                box.Name,
		Private:             box.Private,
		ShortDescription:    box.ShortDescription,
		Tag:                 box.Tag,
		UpdatedAt:           box.UpdatedAt,
		Username:            box.Username,
	}

	versions := &models.Versions{}

	if err := tx.Eager().Where("box_id = ?", box.ID).All(versions); err != nil {
		return errors.WithStack(err)
	}

	resp.Versions = *versions

	latest, err := versions.GetLatest()
	if err != nil {
		return c.Error(503, errors.New(fmt.Sprintf("could not get latest: %s", err)))
	}

	if latest.Version != "" {
		resp.CurrentVersion = &latest
	}

	return c.Render(200, r.JSON(resp))
}
