package actions

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/flyinprogrammer/vlad/models"
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/pkg/errors"
)

const (
	MaxFileSize = int64(1024 * 100)
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Object)
// DB Table: Plural (objects)
// Resource: Plural (Objects)
// Path: Plural (/objects)
// View Template Folder: Plural (/templates/objects/)

// ObjectsResource is the resource for the Object model
type ObjectsResource struct {
	buffalo.Resource
}

func (v ObjectsResource) Upload(c buffalo.Context) error {
	objectID := c.Param("id")

	object := &models.Object{}
	provider := &models.Provider{}
	version := &models.Version{}
	box := &models.Box{}

	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	if err := tx.Find(object, objectID); err != nil {
		return errors.WithStack(err)
	}

	if err := tx.Find(provider, object.ProviderID); err != nil {
		return errors.WithStack(err)
	}

	if err := tx.Find(version, provider.VersionID); err != nil {
		return errors.WithStack(err)
	}

	if err := tx.Find(box, version.BoxID); err != nil {
		return errors.WithStack(err)
	}

	boxPath := fmt.Sprintf("/%s/boxes/%s/versions/%s/providers/%s.box", box.Username, box.Name, version.Version, provider.Name)
	realPath := filepath.Join("/tmp", boxPath)
	realDir := filepath.Dir(realPath)
	if err := os.MkdirAll(realDir, 0755); err != nil {
		return errors.WithStack(err)
	}

	file, err := os.Create(realPath)
	if err != nil {
		return errors.WithStack(err)
	}
	defer file.Close()

	defer c.Request().Body.Close()

	_, err = io.Copy(file, c.Request().Body)
	if err != nil {
		return errors.WithStack(err)
	}

	provider.Hosted = true
	provider.HostedToken = object.ID.String()

	verrs, err := tx.ValidateAndUpdate(provider)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		c.Set("errors", verrs)
		return c.Render(422, r.Auto(c, provider))
	}

	return c.Render(200, r.JSON(provider))
}

func (v ObjectsResource) Create(c buffalo.Context) error {
	object := &models.Object{}

	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	username := c.Param("username")
	name := c.Param("name")
	version := c.Param("version")
	provider := c.Param("provider")

	query := tx.Q().Join("versions", "versions.id=providers.version_id").
		Join("boxes", "boxes.id=versions.box_id").
		Where("boxes.username = ?", username).
		Where("boxes.name = ?", name).
		Where("versions.version = ?", version).
		Where("providers.name = ?", provider)

	providers := &models.Providers{}

	if err := query.All(providers); err != nil {
		return errors.WithStack(err)
	}

	if len(*providers) == 0 {
		return c.Error(404, errors.New(fmt.Sprintf("no provider found for: username: %s name: %s version: %s provider %s", username, name, version, provider)))
	}

	if len(*providers) > 1 {
		return c.Error(503, errors.New(fmt.Sprintf("too many (%d) boxes found", len(*providers))))
	}

	object.ProviderID = (*providers)[0].ID

	verrs, err := tx.ValidateAndCreate(object)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		c.Set("errors", verrs)
		return c.Render(422, r.Auto(c, object))
	}

	object.UploadPath = fmt.Sprintf("%s/%s/%s", App().Options.Host, "v1/object", object.ID)

	verrs, err = tx.ValidateAndUpdate(object)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		c.Set("errors", verrs)
		return c.Render(422, r.JSON(object))
	}

	return c.Render(200, r.JSON(object))
}

func (v ObjectsResource) FetchBox(c buffalo.Context) error {

}
